<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>VR Slideshow — A-Frame assets-safe (10 panels)</title>

    <!-- A-Frame + look-at -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@1.0.0/dist/aframe-look-at-component.min.js"></script>

    <style>
      body { background:#0b0b0b; color:#eee; font-family:Arial,Helvetica,sans-serif; padding:18px; }
      h2 { margin:0 0 8px 0; }
      #controls { max-width:720px; }
      #imageList { margin-top:12px; }
      .thumbWrapper { display:inline-block; position:relative; margin:6px; }
      .thumbWrapper img { width:84px; height:84px; object-fit:cover; border-radius:6px; border:2px solid #444; }
      .removeBtn { position:absolute; top:-6px; right:-6px; background:#c33; color:#fff; border:none; width:22px; height:22px; border-radius:50%; cursor:pointer; }
      button, select, input { font-size:14px; padding:6px; }
      #status { margin-top:10px; color:#bbb; font-size:13px; }
      #debug { color:#ffd47a; font-size:13px; margin-top:10px; }
      a { color:#66aaff; }
    </style>
  </head>

  <body>
    <div id="controls">
      <h2>VR Slideshow — Select Photos</h2>

      <!-- Single-file picker (Quest picks one at a time) -->
      <input id="filePicker" type="file" accept="image/*" />
      <span style="margin-left:12px;">Tip: repeat <strong>Choose Files</strong> to add more images (Quest only picks one at a time).</span>

      <p style="margin-top:8px;">
        Panel size:
        <select id="panelSize">
          <option value="medium" selected>Medium (recommended)</option>
          <option value="large">Large</option>
          <option value="small">Small</option>
        </select>
        &nbsp;&nbsp;
        Replace interval (sec):
        <input id="replaceInterval" type="number" min="1" max="30" value="5" style="width:70px;" />
      </p>

      <p>
        Visible panels: <strong>10</strong> (fixed)
      </p>

      <button id="startBtn" disabled>Start Slideshow</button>
      <div id="status">No images selected yet.</div>

      <div id="imageList" aria-live="polite"></div>

      <div id="debug" aria-live="polite"></div>

      <p style="margin-top:12px;font-size:13px;color:#aaa;">
        When ready: press <strong>Start Slideshow</strong>. The page will prepare textures and then prompt to enter VR.<br>
        Diagram link (repo asset): <a href="assets/diagram.png" target="_blank">assets/diagram.png</a><br>
      </p>
    </div>

    <!-- VR scene - hidden until Start triggers it.
         NOTE: <a-assets> is required for WebXR textures to work reliably on Quest. -->
    <a-scene id="vrScene" embedded vr-mode-ui="enabled:true" style="display:none; height:100vh;">
      <a-assets id="aAssets">
        <!-- dynamically injected <img id="img0"> elements will go here -->
      </a-assets>

      <a-entity id="cameraRig">
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>
      </a-entity>

      <!-- big dark interior sphere -->
      <a-sphere radius="30" segments-height="48" segments-width="64" scale="-1 1 1" color="#000"></a-sphere>

      <a-entity id="panelContainer"></a-entity>

      <!-- in-VR debug if needed -->
      <a-entity id="vrDebug" visible="false" position="-1.6 2 -2">
        <a-plane width="3.2" height="1.4" color="#000" opacity="0.8"></a-plane>
        <a-text id="vrDebugText" value="" position="-1.48 0.52 0.01" align="left" wrap-count="30" color="#ffd47a"></a-text>
      </a-entity>
    </a-scene>

    <script>
      // Config
      const VISIBLE_PANELS = 10;
      const DEFAULT_PANEL_SIZES = { small: 4.0, medium: 8.0, large: 12.0 };

      // DOM
      const filePicker = document.getElementById('filePicker');
      const startBtn = document.getElementById('startBtn');
      const imageListDiv = document.getElementById('imageList');
      const statusEl = document.getElementById('status');
      const debugEl = document.getElementById('debug');
      const aAssets = document.getElementById('aAssets');

      // State
      let fileList = [];
      let metaList = []; // { id: 'img0', url: dataUrl, width, height }
      let panelEntities = [];
      let replaceTimer = null;
      let nextAssetId = 0;

      // Helpers
      function log(msg) {
        console.log(msg);
        debugEl.textContent = String(msg).slice(0, 800);
        try {
          const vrDebugText = document.getElementById('vrDebugText');
          const vrDebug = document.getElementById('vrDebug');
          if (vrDebugText && vrDebug) {
            vrDebugText.setAttribute('value', String(msg).slice(0, 700));
            vrDebug.setAttribute('visible', true);
          }
        } catch(e){}
      }
      function clearLog() {
        debugEl.textContent = '';
        try { document.getElementById('vrDebug').setAttribute('visible', false); } catch(e) {}
      }

      // Convert File -> Base64 data URL using FileReader
      function fileToDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(new Error('FileReader error'));
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });
      }

      // Load image dimensions safely (using an Image created from the data URL)
      function getImageDimensionsFromDataURL(dataUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
          img.onerror = () => reject(new Error('image decode failed'));
          img.src = dataUrl;
        });
      }

      // UI: add thumbnail w/ remove
      function addThumb(dataUrl, idx) {
        const w = document.createElement('div');
        w.className = 'thumbWrapper';
        w.dataset.idx = idx;
        const img = document.createElement('img');
        img.src = dataUrl;
        w.appendChild(img);
        const rm = document.createElement('button');
        rm.className = 'removeBtn';
        rm.innerText = '×';
        rm.title = 'Remove';
        rm.onclick = () => removeImage(idx);
        w.appendChild(rm);
        imageListDiv.appendChild(w);
      }
      function rebuildThumbs() {
        imageListDiv.innerHTML = '';
        metaList.forEach((m,i) => addThumb(m.url, i));
      }
      function removeImage(index) {
        // Remove from metaList and from a-assets DOM
        const meta = metaList[index];
        if (meta && meta.id) {
          const existing = document.getElementById(meta.id);
          if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
        }
        metaList.splice(index, 1);
        fileList.splice(index, 1);
        rebuildThumbs();
        statusEl.textContent = `${metaList.length} images selected.`;
        startBtn.disabled = metaList.length < 1;
      }

      // file picker handler (single-file selection at a time)
      filePicker.addEventListener('change', async (evt) => {
        const files = Array.from(filePicker.files || []);
        if (!files.length) return;
        const f = files[0];
        statusEl.textContent = `Converting ${f.name}...`;
        try {
          const dataUrl = await fileToDataURL(f);
          const dims = await getImageDimensionsFromDataURL(dataUrl);
          const id = `img${nextAssetId++}`;
          // Create an <img id="..."> inside <a-assets> and set src to the dataURL
          const imgEl = document.createElement('img');
          imgEl.setAttribute('id', id);
          imgEl.setAttribute('src', dataUrl);
          imgEl.setAttribute('crossorigin', 'anonymous');
          aAssets.appendChild(imgEl);

          // Store meta
          metaList.push({ id, url: dataUrl, width: dims.width, height: dims.height });
          fileList.push(f);

          addThumb(dataUrl, metaList.length - 1);
          statusEl.textContent = `${metaList.length} images selected.`;
          startBtn.disabled = metaList.length < 1;
          clearLog();
        } catch (err) {
          log('Image conversion error: ' + (err && err.message ? err.message : err));
        } finally {
          filePicker.value = '';
        }
      });

      // Create a plane that references an a-assets img by id (#imgN)
      function createPanel(meta, panelWidth) {
        const radius = 28;
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2*v - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        const depthOffset = (Math.random()-0.5) * 1.2;
        const px = x * (1 + depthOffset/28);
        const py = y * (1 + depthOffset/28);
        const pz = z * (1 + depthOffset/28);

        const plane = document.createElement('a-plane');

        const aspect = meta.width && meta.height ? meta.width/meta.height : 1.5;
        let width = panelWidth;
        let height = Math.max(1.0, panelWidth / aspect);

        plane.setAttribute('width', width);
        plane.setAttribute('height', height);
        plane.setAttribute('position', `${px} ${py} ${pz}`);
        plane.setAttribute('look-at', '#camera');
        // Use the a-assets image reference by id (WebXR-safe)
        plane.setAttribute('material', `src: #${meta.id}; side:double; shader:flat;`);

        // Ken Burns style
        const dur = Math.floor(20000 + Math.random()*20000);
        plane.setAttribute('animation__pos', `property: position; dur: ${dur}; dir: alternate; loop: true; to: ${px + (Math.random()*1-0.5)} ${py + (Math.random()*0.8-0.4)} ${pz}`);
        const scaleTo = 0.95 + Math.random()*0.25;
        plane.setAttribute('animation__scale', `property: scale; to: ${scaleTo} ${scaleTo} 1; dur: ${dur}; dir: alternate; loop: true;`);
        return plane;
      }

      // Build visible panels (using the metaList which already has assets registered)
      async function buildVisiblePanels(panelWidth) {
        const container = document.getElementById('panelContainer');
        panelEntities.forEach(e => { try{ e.parentNode.removeChild(e);}catch(e){} });
        panelEntities = [];
        // initial set
        for (let i=0; i < Math.min(VISIBLE_PANELS, metaList.length); i++) {
          const meta = metaList[i % metaList.length];
          const ent = createPanel(meta, panelWidth);
          container.appendChild(ent);
          panelEntities.push(ent);
        }
        // fill to count if fewer images than panels
        while (panelEntities.length < VISIBLE_PANELS) {
          const meta = metaList[Math.floor(Math.random()*metaList.length)];
          const ent = createPanel(meta, panelWidth);
          container.appendChild(ent);
          panelEntities.push(ent);
        }
      }

      function replaceOne(panelWidth) {
        if (!panelEntities.length || !metaList.length) return;
        const idx = Math.floor(Math.random()*panelEntities.length);
        const old = panelEntities[idx];
        try { old.parentNode.removeChild(old); } catch(e) {}
        const meta = metaList[Math.floor(Math.random()*metaList.length)];
        const ent = createPanel(meta, panelWidth);
        document.getElementById('panelContainer').appendChild(ent);
        panelEntities[idx] = ent;
      }

      // Main Start flow
      startBtn.addEventListener('click', async () => {
        startBtn.disabled = true;
        statusEl.textContent = 'Preparing slideshow — building panels...';
        clearLog();

        if (!metaList.length) { statusEl.textContent = 'Select at least 1 image first.'; startBtn.disabled = false; return; }

        const sizeSetting = document.getElementById('panelSize').value;
        const panelWidth = DEFAULT_PANEL_SIZES[sizeSetting] || DEFAULT_PANEL_SIZES.medium;

        try {
          // Wait until all <img> assets have finished loading (important)
          // Check each injected asset element's complete/readystate
          const assetImgs = Array.from(aAssets.querySelectorAll('img'));
          // If there are no assets yet, we still proceed (shouldn't happen because metaList.length>0)
          await Promise.all(assetImgs.map(img => {
            return new Promise((resolve, reject) => {
              if (img.complete && img.naturalWidth > 0) return resolve();
              img.onload = () => resolve();
              img.onerror = () => {
                log('Failed to load asset: ' + (img.id || 'unknown'));
                resolve(); // resolve to avoid blocking — missing textures show white but others load
              };
            });
          }));

          await buildVisiblePanels(panelWidth);
        } catch (err) {
          log('Error building panels: ' + (err && err.message ? err.message : err));
          startBtn.disabled = false;
          return;
        }

        // Show VR scene and enter VR (user gesture)
        document.getElementById('controls').style.display = 'none';
        const scene = document.getElementById('vrScene');
        scene.style.display = 'block';

        setTimeout(async () => {
          try {
            await scene.enterVR();
          } catch (err) {
            log('Failed to enter VR: ' + (err && err.message ? err.message : err));
            document.getElementById('controls').style.display = '';
            scene.style.display = 'none';
            startBtn.disabled = false;
            return;
          }

          // start replacement timer after VR entered
          const interval = Math.max(1, parseFloat(document.getElementById('replaceInterval').value)||5);
          if (replaceTimer) clearInterval(replaceTimer);
          replaceTimer = setInterval(() => {
            try {
              replaceOne(panelWidth);
            } catch (e) {
              log('Replace error: ' + e);
            }
          }, interval * 1000);

          statusEl.textContent = 'Slideshow running.';
          clearLog();
        }, 120);
      });

      // Cleanup
      window.addEventListener('beforeunload', () => {
        if (replaceTimer) clearInterval(replaceTimer);
      });
    </script>
  </body>
</html>
